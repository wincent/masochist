---
description: Reflections on the Advent of Code, 2024 edition
tags: blog
title: Advent of Code 2024
---

Seeing as I hang out on [Hacker News](https://news.ycombinator.com/), I've been aware of [Advent of Code](https://adventofcode.com) for many years now, but it was only in 2023 that I participated for the first time.

In 2023, I fully completed 16 days (both parts)[^hint] and partially completed an additional 4 days (only the first part). There was one day that I attempted but didn't even solve the first part, and 4 days in which I didn't participate at all. I optimized for getting the solutions quickly, not necessarily elegantly, and if I felt like I was taking "too much" time on a particular problem, I stopped.

[^hint]: On one of those days, I got stuck, and ended up looking on Reddit for a hint for how to proceed with the second part.

In 2024, I completed all 25 days, and the whole business felt subjectively easier. I wasn't sure though: was it _really_ easier than the year before, or had I just gotten a bit better at solving this kind of question? Alternatively, had I tried a bit harder in 2024?[^not] Might it even be true that I was, um, "scrappier" in 2024; that is, more willing to throw elegance, purity, and truth out the window in service of getting the right answer?

[^not]: I don't think so, as I there were only a few days where I felt like I took longer than I should have to arrive at a solution. For the most part I felt like I got things done more quickly than the previous year.

Ideally, I want my solutions to be based on applying my toolkit of data structures and algorithms to the problem at hand. I think it's ok to look up details of a specific algorithm that you know about but which you can't necessarily implement from memory alone, but not to go onto Reddit in order to have a recipe for how to solve the problem handed to you on a platter. This year, for example, I used [Dijkstra's algorithm](https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm) a couple of times (day 16 and day 18); this is a path-finding algorithm that is simple enough that I can mostly remember the shape of it even if I only make use of it once a year, but my first cut wasn't quite right and I needed to check the details. On day 23, I used the [Bron-Kerbosch algorithm](https://en.wikipedia.org/wiki/Bron%E2%80%93Kerbosch_algorithm) for finding the maximum clique in a graph; that was a case where I knew the kind of algorithm I wanted, but couldn't recall the name of it, so I went to Wikipedia and skimmed through the [list of Graph algorithms](https://en.wikipedia.org/wiki/List_of_algorithms#Graph_algorithms) to find what I was looking for. Given that I couldn't remember the name, I _definitely_ wouldn't have been able to implement the algorithm without looking it up. That seems like fair game to me.

Likewise, for non-trivial data structures (ie. anything that doesn't come with the language or standard library), I think it's ok to copy an implementation I've previously written. This year, the only such thing I grabbed was a [binary heap](https://en.wikipedia.org/wiki/Binary_heap) implementation and the corresponding thin wrapper around it that turns it into a priority queue. At one point, I thought I might use a [Union-Find](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) but I ended up not doing so. I wouldn't get very far writing a Union-Find implementation from scratch without looking it up. And I think I could write more than 50% of a heap implementation without looking anything up, but it would probably have bugs, and I'd have to look up the rest anyway, so I figure I may as well use an at least somewhat battle-tested implementation that I myself have previously produced.

Needless to say, no LLMs for something like Advent of Code. Using them seems not to be in the spirit of the exercise.

So, I've got principles, if you know what I'm saying. But there were a couple of days this time that troubled me, where I used "by-hand" analysis of the problem input, or what I'd call "extrinsic knowledge" to strongly guide the solution, as opposed to coming at things from "first principles":

- On day 17, I figured out what the provided byte-code was supposed to do (ie. I effectively "disassembled" the byte-code and wrote down exactly how the information would flow through the registers), and used that knowledge to run a search over possible values, effectively running the computation in reverse, ultimately arriving back at the necessary initial value. In other words, I didn't write an algorithm that would run over the input data and spit out an answer; instead, I wrote code that would leverage some analysis (that I could have done with pencil and paper) to spit out an answer.

- On day 24, I used knowledge of how binary addition can be implemented using logic gates to explore the problem input finding deviations from the expected wiring. That is to say, instead of taking the problem input and asking "how can I make use of data structures and algorithms to solve this task?", I asked "how can I make use of data structures and algorithms, _combined with knowledge of how logic gates can be used to perform addition_[^knowledge], to solve this task".

[^knowledge]: Knowledge that I vaguely recalled, but which I obviously had to look up online to actually get the details right.

Both of these felt somehow like "cheating", but the truth is I cared more about getting the answer than doing it in a "pure" way, so I went with it. Based on comments from folks at work, I feel like at least a few of my colleagues were able to produce more "fundamental" solutions for both of these days.

In any case, let's get back to our initial question. Was Advent of Code 2024 easier than 2023? That's a very hard question to reliably answer, so I posted an ultra-scientific poll at work and found that 9 respondents thought 2024 _was_ easier, and 1 thought it was about the same. I guess that settles it, then.
