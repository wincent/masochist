---
tags: blog
title: Searching for the Holy Grail
twitter: https://twitter.com/wincent/status/888056462781538304
---

I [recently came to the conclusion](https://twitter.com/wincent/status/887743724867903488) that, when it comes to programming languages, there is no Holy Grail, just a bunch of cups, and perhaps we should just get on with drinking.

I've worked with a lot of languages over the years. I started as a 10-year-old writing in [Commodore BASIC](https://en.wikipedia.org/wiki/Commodore_BASIC) on the [Commodore 64](https://en.wikipedia.org/wiki/Commodore_64), progressed to [AmigaBASIC](https://en.wikipedia.org/wiki/AmigaBASIC), [AMOS](https://en.wikipedia.org/wiki/AMOS_%28programming_language%29) and finally [68000 assembly](https://en.wikipedia.org/wiki/Motorola_68000) on the [Amiga 500](https://en.wikipedia.org/wiki/Amiga_500), and briefly dipped into [x86 assembly](https://en.wikipedia.org/wiki/X86_assembly_language) during my short stint as the owner of a [486SX33](https://en.wikipedia.org/wiki/Intel_80486). At college I did programming courses that used [Ada](https://en.wikipedia.org/wiki/Ada_%28programming_language%29).

Sadly, I don't have any records of any of the programs that I wrote back in those days, although I fondly recall some. Whatever remains of them, fragilely stored on flimsy [floppy disks](https://en.wikipedia.org/wiki/Floppy_disk) or inscribed on [dot-matrix](https://en.wikipedia.org/wiki/Dot_matrix_printing) printouts, is probably decomposing under countless layers of land-fill by now.

I got my first Mac in the mid-90s. My earliest Mac programs were in [REALbasic](https://en.wikipedia.org/wiki/Xojo), but with the birth of the web I wrote "discussion boards" with flat-file "databases" in [Perl](https://www.perl.org/), "weblogs" in [PHP](http://php.net/), and I learned [HTML](https://en.wikipedia.org/wiki/HTML), [CSS](https://en.wikipedia.org/wiki/Cascading_Style_Sheets) and [JS](https://en.wikipedia.org/wiki/JavaScript), as you do. Almost all of that early stuff is lost too.

It's not until the 2000s that [my personal fossil record](https://github.com/wincent) has some surviving evidence. I used the [CVS](https://en.wikipedia.org/wiki/Concurrent_Versions_System), [Subversion](https://en.wikipedia.org/wiki/Apache_Subversion), and [SVK](https://en.wikipedia.org/wiki/SVK) version control systems, and some of the artifacts that I created in those systems survived into the [Git](https://en.wikipedia.org/wiki/Git) era, where I expect they'll enjoy a much longer digital [half-life](https://en.wikipedia.org/wiki/Half-life).

I wrote large projects in [C](https://en.wikipedia.org/wiki/C_%28programming_language%29) and [Objective-C](https://en.wikipedia.org/wiki/Objective-C) on the desktop, and for the web I learned [Ruby](https://www.ruby-lang.org/) and went deep into JS. These were my professional languages that paid the bills for me, but along the way I explored and wrote side-projects in [Haskell](https://www.haskell.org/), [Go](https://golang.org/) and [Lua](https://www.lua.org/). At work I sometimes have to dip into [Hack](http://hacklang.org/). I've written my fair share of [Vimscript](https://en.wikipedia.org/wiki/Vim_%28text_editor%29) and [Bash](https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29) (etc) stuff. Sometimes, I write snippets of [Python](https://www.python.org/). My latest experiments have been with [Reason](https://reasonml.github.io/).

Looking back over that history, I envy the simplicity of the constrained choices that I used to make. I wrote BASIC because it came with the computer. I learned assembly because it was the only tool for the job (if by "the job" you meant writing games with fast graphics). Some of the choices were totally serendipitous and not really choices at all; I learned AMOS because someone gave me a copy of it. I learned Perl because it was basically "the way" that CGI was done back in the day. I learned C and Objective-C because those were the languages with which you could access Apple's APIs and build desktop apps.

Starting with [Rails](https://en.wikipedia.org/wiki/Ruby_on_Rails), the pace of innovation and renewal seemed to really take off. Languages and frameworks were spawned en masse, duking it out with one another to achieve domination and establish a "new paradigm". The choices became less clear, the list of contenders impractically long. For all the languages I did learn, there are many more that I didn't have time to even dabble in (not just the older languages — [Erlang](https://www.erlang.org/), [Java](https://en.wikipedia.org/wiki/Java_%28programming_language%29), [C++](https://en.wikipedia.org/wiki/C%2B%2B) — but countless others that they have spawned or influenced: [Dart](https://www.dartlang.org/), [Rust](https://www.rust-lang.org/), [Elm](http://elm-lang.org/), [PureScript](http://www.purescript.org/), [CoffeeScript](http://coffeescript.org/), [Elixir](https://elixir-lang.org/), [Scala](https://www.scala-lang.org/), [Kotlin](https://kotlinlang.org/), [D](https://en.wikipedia.org/wiki/D_%28programming_language%29) and many others).

I think there are some pretty clear conclusions to draw here: either we as language designers aren't very good at what we do, or as human beings we're afflicted with a crippling case of not-invented-here syndrome and an evolved inability to be happy and productive with the tools that we're given. Either way, the costs are immense: we spend a disproportionate amount of time and energy reinventing our tooling relative to how much we invest in actually building things with those tools. It's easy to mistake motion for progress, I guess.

Why am I writing about this now? I think it's because I've felt increasingly restless about JavaScript. JavaScript is an increasingly multi-paradigm language that wants to be all things to all people. It has "Feature Envy". Its aggressively forward-looking development model (the whole TC39 process with its keen involvement by significant industry players with the power to effect meaningful change in the deployed ecosystem, and the availability and widespread use of tools like [Babel](http://babeljs.io/) that enable rapid and aggressive experimentation) together with the need to maintain backwards compatibility forever (you can't "break the web") mean that it accrues an ever-growing, never-shrinking set of functionality and syntax. It has — or will have — almost every feature available in any other language, up to and including a Kitchen Sink capability, but will probably stop short of the one thing that I really wish it had (a real, [not-bolted-on type system](https://flow.org/)). JavaScript is simultaneously the best language to teach to beginners (there is no cheaper way to build something with a UI that will run *anywhere*) and the worst (welcome to an ecosystem with a rapidly churning set of tooling that's metastisizing fast enough that it may well collapse into a black hole one day).

Yet, I've come to the conclusion that all this searching for something better is a [fool's errand](https://en.wikipedia.org/wiki/Fool%27s_errand). You don't make something better by combining the best bits of other languages. The most you can do is to take an opinionated stance about something that you consider to be really important, focus on getting that one thing really right, and then get on with the business of building useful things with it. Note that it doesn't suffice to be *just* opinionated; you *also* have to be focused. Here are some examples of opinionated, focused stances:

- Haskell:
  - Core thesis: Fully unlock the power of abstraction with a purely functional, lazily evaluated core.
  - Advantage: You get an expressive, sophisticated type system that allows you to succinctly materialize ideas with a high degree of machine-assisted verification.
  - Trade-off: Some things, like modifying deeply nested immutable data structures, are hard.
- Go:
  - Core thesis: Simplicity is paramount.
  - Advantage: Out of simple primitives you can build robust, highly-performant concurrent solutions.
  - Trade-off: Code is "boring", "verbose", "pedestrian".
- C:
  - Core thesis: Abstraction is overrated.
  - Advantage: Speak to the [Von Neumann architecture](https://en.wikipedia.org/wiki/Von_Neumann_architecture) in its native tongue (almost) to build fast things, without needing to learn processor-specific assembly language.
  - Trade-off: When you build stuff out of gun powder, wire, and spark-plugs, you just may singe off your eyebrows.

If you try to make these languages better by blending together their best elements you wind up with behemoths like JavaScript and C++. These are not bad languages; they've been extremely successful, and many great things get built using them. And yet, people can't resist somehow trying to "fix" them, either by augmentation or outright replacement. Something is rotten in the state of programming languages.

Inevitably with the good stuff comes some baggage. Sometimes the elements don't combine well. You can't make a better Ruby, for example, by adding Haskell's strong static typing to it, because what you'd get wouldn't be the loose, fluid, pleasant, expressiveness of Ruby: you'd just get Haskell with an awkward syntax. I've previously remarked that programming in Ruby is like driving a rubber car without a seatbelt; that sounds like fun in a weird kind of way, and it is. By the time you've added static typing the language is no longer a car, nor is it made of rubber, and I guess it doesn't really make sense to ask whether it has a seatbelt or not any more (whatever "it" is). Large, growing languages inevitably tend towards resembling Frankenstein's monster over time.

All of this may strike you as being perilously close to just plain old obvious common-sense, and you may wonder, why I am bothering to write it? Why would I ever have thought that there was a Holy Grail in the first place?

It crept up on me insidiously at first. About 10 years ago I first got exposed to the idea that you should learn a new programming language every year, not necessarily to add to your practical tool-kit, but to expand your mind. Haskell was a popular choice for this purpose back then. The notion was that you should seek out "novel" ideas — note this means novel to *you* and not necessarily something universally recent — and train your mind by grappling with them. At the very least you kept your mental axe sharp by exercising it, and at best you might stumble across something that subtly (or even dramatically) changed your world view and in some nebulous, hard-to-articulate way, "made you a better developer".

Fast forward ten years into this practice, I haven't learned ten new languages, but I have made significant incursions into about five. Even though I never lost sight of the reason why I was going through this whole exercise, there was a primitive, subconscious part of my brain that was wondering if I would end up finding "The One": the language that would somehow feel so "right" and enable me to be so effective that I'd be able to stop searching and settle down for a decade, or two, or three. I'd forgotten that I wasn't engaged in a *search* at all. This is what reading two many blog posts with titles like "Why we're rewriting everything from X to Y" will do to you, given enough time. You start to think like a believer.

This year I was looking around for a new Language of the Year to dive into, but was struggling to find something that met my novelty criterion. Reason/OCaml felt too similar to Haskell. Rust definitely had some novel ideas, but it failed my other criterion: practical applicability (in the sense that I needed to find a *well-suited*, useful, motivating side-project in which to try it out).

I finally decided to go with Reason despite the relative lack of novelty, and this meant honestly confronting myself with the fact that at least part of me — the irrational part — had been holding out, hoping to find a Holy Grail candidate. I had to let go of that. I went in knowing Reason would have some real strengths (eg. fast compile times, great developer experience, solid performance etc) and some down-sides (eg. spartan documentation, few examples, and so on). There'd also be some mixed-bag stuff, like the small community, which you can consider a blessing or a curse depending on how you look at it.

*All* languages are going to suck in some way. But the bright side is that we have *so* many choices available to us now that we can choose languages that suck in the ways that we can tolerate, and conversely, excel in the areas that really matter to us. For me, Reason is interesting because two of the things that it gets really right (having a solid type system, and language-level support for immutable records) happen to represent a couple of the things whose absence really annoys me about JavaScript. I can compromise a lot on the rest — take the good, and the bad — because ultimately it doesn't matter that much to me. I'm looking for a cup to drink out of, not a fountain of eternal youth.

In closing, I want to make sure that this post doesn't end up being yet another "Why I'm rewriting everything from X to Y". I'll continue to use the other "cups" I have in my cupboard. The cup I choose at any particular moment will depend on the circumstances. I am sure that every now and again I'll want to try out a new vessel or two. But if you ever see me with a distant, glazed-over look in my eyes, and I look like I'm about to ride off towards the horizon in search of some mythical language that doesn't exist — or worse still, I start showing signs of wanting to design my own — please try to snap me out of it. A slap in the face and, if that doesn't work, a bucket of cold water should do the trick.

<small><em>Discuss: [Twitter](https://twitter.com/wincent/status/888056462781538304)</em></small>
